# Артемов Никита Владиславович БПИ219
## Вариант 2

Сформировать массив B только из тех элементов массива А, которые
не совпадают с его первым и последним элементами.

#### Задание решено на:
- [5 баллов]()
- [6 баллов]()

## Решение на 5 баллов
Исходный код на C: [./main.c](./main.c)
```sh
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *file = NULL;
    if (!strcmp(argv[1], "-f")) {
        if (argc > 3){
            file = fopen(argv[3], "r");
        } else {
            file = fopen("array_in.txt", "r");
        }
    }
    int n = atoi(argv[2]);
    int* a = (int*)malloc(sizeof(int)*n);
    
    for (int i = 0; i < n; i++) {
        if (!strcmp(argv[1], "-r")) {
            a[i] = rand() % 2 * (-1000) + rand() % 1000;
        } else if (!strcmp(argv[1], "-f")) {
            fscanf(file, "%d", &a[i]);
        } else {
            scanf("%d", &a[i]);
        }
    }
    
    int k = 0;
    for (int i = 1; i < n - 1; i++) {
        if (a[i] != a[0] && a[i] != a[n - 1]) {
            k++;
        }
    }
    
    int* b = (int*)malloc(sizeof(int)*k);;
    k = 0;
    for (int i = 1; i < n - 1; i++) {
        if (a[i] != a[0] && a[i] != a[n - 1]) {
            b[k] = a[i];
            k++;
        }
    }

    if (!strcmp(argv[1], "-f")) {
        fclose(file);
        file = NULL;
    }
    if (strcmp(argv[1], "-c")) {
        if (argc == 5){
            file = fopen(argv[4], "w");
        } else {
            file = fopen("array_out.txt", "w");
        }
        
    }
    
    for (int i = 0; i < k; i++) {
        if (!strcmp(argv[1], "-c")){
            printf("%d\t", b[i]);
        } else {
            fprintf(file, "%d\t", b[i]);
        }
    }
    
    if (strcmp(argv[1], "-c")) {
        fclose(file);
    }
    free(b);
    free(a);
    return 0;
}
```

В реализованной функции использованы функции с передачей данных через параметры, а также локальные переменные.
Связь регистров и параметров функций в языке Си: ![img.jpg](img.jpg)

Программа при вызове ./"filename".out требует аргументы командной строки.

#### Порядок аргументов:
1. -f/-r/-с (файловый ввод и вывод / массив генерируется рандомно / консольный ввод) - обязательный аргумент
2. <натуральное число больше 2> (длина массива) - обязательный аргумент
3. <полный путь к файлу для ввода массива> - необязательный аргумент
4. <полный путь к файлу для вывода массива> - необязательный аргумент

При вводе некорректных данных - UB, поэтому требование к работе с программой - это ввод корректных данных.

#### По умолчанию:
- ввод происходит из файла [./array_in.txt](./array_in.txt)
- вывод происходит в файл [./array_out.txt](./array_out.txt)
- при аргументе командной строки -r генерируются числа рандомно от -1000 до 1000

Исходный файл был откомпилирован без оптимизирующих и отладочных опций:
```sh
$gcc main.c
```
Полученный файл: [./a.out](./a.out)

А также запущен и протестирован:
```sh
$./a.out <command line arguments>
```
Результаты тестов: [./tests-1](./tests-1)

Исходный файл ассемблирован без оптимизирующих и отладочных опций:
```sh
$gcc -S -O0 -masm=intel main.c
```
Полученный файл: [./asm.s](./asm.s )

В его копию были добавлены комментарии: [./asm_with_comments.s](./asm_with_comments.s )
; в том числе были добавлены комментарии, описывающие передачу фактических параметров и перенос возврщаемого результата и связь между регистрами и параметрами языка СИ.

Итоговый ассемблерный файл был откомпилирован без отладочных опций:
```sh
$gcc asm.s -o asm.out
```
Получившийся файл был запущен и протестирован:
```sh
$./asm.out <command line arguments>
```
Полученный файл: [./asm.out](./asm.out)

Результаты тестов:  [./tests-2](./tests-2)

С целью избавиться от макросов файл был ассемблирован с флагом -fno-asynchronous-unwind-tables:
```sh
$gcc main.c -O0 -fno-asynchronous-unwind-tables -masm=intel -S -o asm_without_macroses.s
```
Полученный файл: [asm_without_macroses.s](asm_without_macroses.s ). 
С ним были проделаны аналогичные действия.

Результаты тестов:  [./tests-3](./tests-3)

> Результаты тестовых прогонов всех программ совпадают.
> Значит, они функционально эквивалентны.

## Решение на 6 баллов

Чтобы максимизировать использование регистров, код был ассемблирован с флагом -O2:
```sh
$gcc -O2 -fno-asynchronous-unwind-tables -masm=intel -S main.c
```

Полученный файл был отредактирован: [./asm_with_registers.s](./asm_with_registers.s)

В main память на стеке выделялась только под массивы.

Полученная программа также была откомпилирована, запущена и протестирована:
```sh
$gcc main.s -o main.out
$./main.out <command line arguments>
```

Результаты тестов: [./tests-4](./tests-4)

> Результаты тестовых прогонов совпадают с предыдущими.
> Значит, они функционально эквивалентны.
